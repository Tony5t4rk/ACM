\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// pbds}

\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}bits/extc++.h\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{\PYGZus{}\PYGZus{}gnu\PYGZus{}pbds}\PYG{p}{;}

\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} tree \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{k}{template}\PYG{o}{\PYGZlt{}} \PYG{k}{typename} \PYG{n}{Key}\PYG{p}{,}
          \PYG{k}{typename} \PYG{n}{Mapped}\PYG{p}{,}
          \PYG{k}{typename} \PYG{n}{Cmp\PYGZus{}Fn} \PYG{o}{=} \PYG{n}{std}\PYG{o}{::}\PYG{n}{less}\PYG{o}{\PYGZlt{}}\PYG{n}{Key}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
          \PYG{k}{typename} \PYG{n}{Tag} \PYG{o}{=} \PYG{n}{rb\PYGZus{}tree\PYGZus{}tag}\PYG{p}{,}
          \PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{Node\PYGZus{}Cltr}\PYG{p}{,}
                   \PYG{k}{typename} \PYG{n}{Node\PYGZus{}Itr}\PYG{p}{,}
                   \PYG{k}{typename} \PYG{n}{Cmp\PYGZus{}Fn\PYGZus{}}\PYG{p}{,}
                   \PYG{k}{typename} \PYG{n}{\PYGZus{}Alloc\PYGZus{}}\PYG{o}{\PYGZgt{}} \PYG{k}{class} \PYG{n+nc}{Node\PYGZus{}Update} \PYG{o}{=} \PYG{n}{null\PYGZus{}node\PYGZus{}update}\PYG{p}{,}
          \PYG{k}{typename} \PYG{n}{\PYGZus{}Alloc} \PYG{o}{=} \PYG{n}{std}\PYG{o}{::}\PYG{n}{allocator}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}

\PYG{n}{\PYGZus{}\PYGZus{}gnu\PYGZus{}pbds}\PYG{o}{::}\PYG{n}{tree}\PYG{o}{\PYGZlt{}} \PYG{n}{Key}\PYG{p}{,} \PYG{n}{Mapped}\PYG{p}{,} \PYG{n}{Cmp\PYGZus{}Fn}\PYG{p}{,} \PYG{n}{Tag}\PYG{p}{,} \PYG{n}{Node\PYGZus{}Update}\PYG{p}{,} \PYG{n}{\PYGZus{}Alloc} \PYG{o}{\PYGZgt{}}

\PYG{c+cm}{/*}

\PYG{c+cm}{Member types:}
\PYG{c+cm}{  Key:}
\PYG{c+cm}{    Key type.}
\PYG{c+cm}{  Mapped:}
\PYG{c+cm}{    Map type.}
\PYG{c+cm}{  Cmp\PYGZus{}Fn:}
\PYG{c+cm}{    Comparison functior.}
\PYG{c+cm}{  Tag:}
\PYG{c+cm}{    Instantiating data structure type}
\PYG{c+cm}{    \PYGZus{}\PYGZus{}gnu\PYGZus{}pbds::ov\PYGZus{}tree\PYGZus{}tag: Ordered\PYGZhy{}vector tree.}
\PYG{c+cm}{    \PYGZus{}\PYGZus{}gnu\PYGZus{}pbds::rb\PYGZus{}tree\PYGZus{}tag: Red\PYGZhy{}black tree;}
\PYG{c+cm}{    \PYGZus{}\PYGZus{}gnu\PYGZus{}pbds::splay\PYGZus{}tree\PYGZus{}tag: Splay tree.}
\PYG{c+cm}{  Node\PYGZus{}Update:}
\PYG{c+cm}{    Updates nodes, restores invariants when invalidated.}
\PYG{c+cm}{    XXX See design::tree\PYGZhy{}based\PYGZhy{}containers::node invariants.}
\PYG{c+cm}{  \PYGZus{}Alloc:}
\PYG{c+cm}{    Allocator type.}


\PYG{c+cm}{Member functions:}
\PYG{c+cm}{  insert(\PYGZob{}key, mapped\PYGZcb{}):}
\PYG{c+cm}{    Insert element.}
\PYG{c+cm}{  erase(\PYGZob{}key, mapped\PYGZcb{}):}
\PYG{c+cm}{    Delete element.}
\PYG{c+cm}{  order\PYGZus{}of\PYGZus{}key(\PYGZob{}key, mapped\PYGZcb{}):}
\PYG{c+cm}{    Get the rank of \PYGZob{}key, mapped\PYGZcb{}.}
\PYG{c+cm}{  find\PYGZus{}by\PYGZus{}order(int x):}
\PYG{c+cm}{    Find the k\PYGZhy{}th element. Return iterator.}
\PYG{c+cm}{  join(tree t):}
\PYG{c+cm}{    Insert the tree t into the tree if the origin tree type is the same ans there are no duplicate elements.}
\PYG{c+cm}{  split(value, t):}
\PYG{c+cm}{    Split the tree, the origin tree contains elements that are less than or equal to value, the tree t contains elements that are greater to value.}
\PYG{c+cm}{  lower\PYGZus{}bound(value):}
\PYG{c+cm}{    Reture the iterator of the first element greater or equal to value.}
\PYG{c+cm}{  upper\PYGZus{}bound(value):}
\PYG{c+cm}{    Reture the iterator of the first element greater to value.}

\PYG{c+cm}{*/}
\end{Verbatim}
